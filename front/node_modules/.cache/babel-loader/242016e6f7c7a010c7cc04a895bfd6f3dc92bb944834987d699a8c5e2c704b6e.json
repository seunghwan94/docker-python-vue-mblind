{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { combineTransactionSteps, getChangedRanges, findChildrenInRange, getMarksBetween, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { tokenize, find, registerCustomProtocol, reset } from 'linkifyjs';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink;\n  }\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value);\n  }\n  return false;\n}\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nfunction autolink(options) {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      const {\n        tr\n      } = newState;\n      const transform = combineTransactionSteps(oldState.doc, [...transactions]);\n      const changes = getChangedRanges(transform);\n      changes.forEach(({\n        newRange\n      }) => {\n        // Now let’s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock);\n        let textBlock;\n        let textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n        } else if (nodesInChangedRanges.length\n        // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n        && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n        }\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '');\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol));\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false;\n          }\n          linksBeforeSpace.filter(link => link.isLink)\n          // Calculate link position.\n          .map(link => ({\n            ...link,\n            from: lastWordAndBlockOffset + link.start + 1,\n            to: lastWordAndBlockOffset + link.end + 1\n          }))\n          // ignore link inside code mark\n          .filter(link => {\n            if (!newState.schema.marks.code) {\n              return true;\n            }\n            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n          })\n          // validate link\n          .filter(link => options.validate(link.value))\n          // Add link mark.\n          .forEach(link => {\n            if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n              return;\n            }\n            tr.addMark(link.from, link.to, options.type.create({\n              href: link.href\n            }));\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\nfunction clickHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a, _b;\n        if (event.button !== 0) {\n          return false;\n        }\n        if (!view.editable) {\n          return false;\n        }\n        let a = event.target;\n        const els = [];\n        while (a.nodeName !== 'DIV') {\n          els.push(a);\n          a = a.parentNode;\n        }\n        if (!els.find(value => value.nodeName === 'A')) {\n          return false;\n        }\n        const attrs = getAttributes(view.state, options.type.name);\n        const link = event.target;\n        const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;\n        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;\n        if (link && href) {\n          window.open(href, target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\nfunction pasteHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const {\n          state\n        } = view;\n        const {\n          selection\n        } = state;\n        const {\n          empty\n        } = selection;\n        if (empty) {\n          return false;\n        }\n        let textContent = '';\n        slice.content.forEach(node => {\n          textContent += node.textContent;\n        });\n        const link = find(textContent, {\n          defaultProtocol: options.defaultProtocol\n        }).find(item => item.isLink && item.value === textContent);\n        if (!textContent || !link) {\n          return false;\n        }\n        options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n        return true;\n      }\n    }\n  });\n}\nconst pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g;\nfunction isAllowedUri(uri, protocols) {\n  const allowedProtocols = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp'];\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme;\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol);\n      }\n    });\n  }\n  // eslint-disable-next-line no-useless-escape\n  return !uri || uri.replace(ATTR_WHITESPACE, '').match(new RegExp(`^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))`, 'i'));\n}\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nconst Link = Mark.create({\n  name: 'link',\n  priority: 1000,\n  keepOnSplit: false,\n  exitable: true,\n  onCreate() {\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol);\n        return;\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);\n    });\n  },\n  onDestroy() {\n    reset();\n  },\n  inclusive() {\n    return this.options.autolink;\n  },\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null\n      },\n      validate: url => !!url\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href');\n        }\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: 'a[href]',\n      getAttrs: dom => {\n        const href = dom.getAttribute('href');\n        // prevent XSS attacks\n        if (!href || !isAllowedUri(href, this.options.protocols)) {\n          return false;\n        }\n        return null;\n      }\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    // prevent XSS attacks\n    if (!isAllowedUri(HTMLAttributes.href, this.options.protocols)) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, {\n        ...HTMLAttributes,\n        href: ''\n      }), 0];\n    }\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setLink: attributes => ({\n        chain\n      }) => {\n        return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n      },\n      toggleLink: attributes => ({\n        chain\n      }) => {\n        return chain().toggleMark(this.name, attributes, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      },\n      unsetLink: () => ({\n        chain\n      }) => {\n        return chain().unsetMark(this.name, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      }\n    };\n  },\n  addPasteRules() {\n    return [markPasteRule({\n      find: text => {\n        const foundLinks = [];\n        if (text) {\n          const {\n            validate\n          } = this.options;\n          const links = find(text).filter(item => item.isLink && validate(item.value));\n          if (links.length) {\n            links.forEach(link => foundLinks.push({\n              text: link.value,\n              data: {\n                href: link.href\n              },\n              index: link.start\n            }));\n          }\n        }\n        return foundLinks;\n      },\n      type: this.type,\n      getAttributes: match => {\n        var _a;\n        return {\n          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        defaultProtocol: this.options.defaultProtocol,\n        validate: this.options.validate\n      }));\n    }\n    if (this.options.openOnClick === true) {\n      plugins.push(clickHandler({\n        type: this.type\n      }));\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        defaultProtocol: this.options.defaultProtocol,\n        type: this.type\n      }));\n    }\n    return plugins;\n  }\n});\nexport { Link, Link as default, pasteRegex };","map":{"version":3,"names":["isValidLinkStructure","tokens","length","isLink","includes","value","autolink","options","Plugin","key","PluginKey","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","doc","eq","preventAutolink","getMeta","tr","transform","combineTransactionSteps","changes","getChangedRanges","forEach","newRange","nodesInChangedRanges","findChildrenInRange","node","isTextblock","textBlock","textBeforeWhitespace","textBetween","pos","nodeSize","undefined","from","to","endsWith","wordsBeforeWhitespace","split","filter","s","lastWordBeforeSpace","lastWordAndBlockOffset","lastIndexOf","linksBeforeSpace","tokenize","map","t","toObject","defaultProtocol","link","start","end","schema","marks","code","rangeHasMark","validate","getMarksBetween","item","mark","type","addMark","create","href","steps","clickHandler","props","handleClick","view","event","button","editable","a","target","els","nodeName","push","parentNode","find","attrs","getAttributes","state","name","_a","_b","window","open","pasteHandler","handlePaste","slice","selection","empty","textContent","content","editor","commands","setMark","pasteRegex","ATTR_WHITESPACE","isAllowedUri","uri","protocols","allowedProtocols","protocol","nextProtocol","scheme","replace","match","RegExp","join","Link","Mark","priority","keepOnSplit","exitable","onCreate","registerCustomProtocol","optionalSlashes","onDestroy","reset","inclusive","addOptions","openOnClick","linkOnPaste","HTMLAttributes","rel","class","url","addAttributes","default","parseHTML","element","getAttribute","tag","getAttrs","dom","renderHTML","mergeAttributes","addCommands","setLink","attributes","chain","setMeta","run","toggleLink","toggleMark","extendEmptyMarkRange","unsetLink","unsetMark","addPasteRules","markPasteRule","text","foundLinks","links","data","index","addProseMirrorPlugins","plugins"],"sources":["../src/helpers/autolink.ts","../src/helpers/clickHandler.ts","../src/helpers/pasteHandler.ts","../src/link.ts"],"sourcesContent":["import {\n  combineTransactionSteps,\n  findChildrenInRange,\n  getChangedRanges,\n  getMarksBetween,\n  NodeWithPos,\n} from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { MultiToken, tokenize } from 'linkifyjs'\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens: Array<ReturnType<MultiToken['toObject']>>) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink\n  }\n\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value)\n  }\n\n  return false\n}\n\ntype AutolinkOptions = {\n  type: MarkType\n  defaultProtocol: string\n  validate: (url: string) => boolean\n}\n\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ newRange }) => {\n        // Now let’s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(\n          newState.doc,\n          newRange,\n          node => node.isTextblock,\n        )\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (\n          nodesInChangedRanges.length\n          // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n          && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')\n        ) {\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            newRange.to,\n            undefined,\n            ' ',\n          )\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '')\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol))\n\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false\n          }\n\n          linksBeforeSpace\n            .filter(link => link.isLink)\n            // Calculate link position.\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // ignore link inside code mark\n            .filter(link => {\n              if (!newState.schema.marks.code) {\n                return true\n              }\n\n              return !newState.doc.rangeHasMark(\n                link.from,\n                link.to,\n                newState.schema.marks.code,\n              )\n            })\n            // validate link\n            .filter(link => options.validate(link.value))\n            // Add link mark.\n            .forEach(link => {\n              if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                return\n              }\n\n              tr.addMark(\n                link.from,\n                link.to,\n                options.type.create({\n                  href: link.href,\n                }),\n              )\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","import { getAttributes } from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\ntype ClickHandlerOptions = {\n  type: MarkType;\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        if (event.button !== 0) {\n          return false\n        }\n\n        if (!view.editable) {\n          return false\n        }\n\n        let a = event.target as HTMLElement\n        const els = []\n\n        while (a.nodeName !== 'DIV') {\n          els.push(a)\n          a = a.parentNode as HTMLElement\n        }\n\n        if (!els.find(value => value.nodeName === 'A')) {\n          return false\n        }\n\n        const attrs = getAttributes(view.state, options.type.name)\n        const link = (event.target as HTMLLinkElement)\n\n        const href = link?.href ?? attrs.href\n        const target = link?.target ?? attrs.target\n\n        if (link && href) {\n          window.open(href, target)\n\n          return true\n        }\n\n        return false\n      },\n    },\n  })\n}\n","import { Editor } from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find } from 'linkifyjs'\n\ntype PasteHandlerOptions = {\n  editor: Editor\n  defaultProtocol: string\n  type: MarkType\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(item => item.isLink && item.value === textContent)\n\n        if (!textContent || !link) {\n          return false\n        }\n\n        options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n\n        return true\n      },\n    },\n  })\n}\n","import {\n  Mark, markPasteRule, mergeAttributes, PasteRuleMatch,\n} from '@tiptap/core'\nimport { Plugin } from '@tiptap/pm/state'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink.js'\nimport { clickHandler } from './helpers/clickHandler.js'\nimport { pasteHandler } from './helpers/pasteHandler.js'\n\nexport interface LinkProtocolOptions {\n  /**\n   * The protocol scheme to be registered.\n   * @default '''\n   * @example 'ftp'\n   * @example 'git'\n   */\n  scheme: string;\n\n  /**\n   * If enabled, it allows optional slashes after the protocol.\n   * @default false\n   * @example true\n   */\n  optionalSlashes?: boolean;\n}\n\nexport const pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi\n\n/**\n * @deprecated The default behavior is now to open links when the editor is not editable.\n */\ntype DeprecatedOpenWhenNotEditable = 'whenNotEditable';\n\nexport interface LinkOptions {\n  /**\n   * If enabled, the extension will automatically add links as you type.\n   * @default true\n   * @example false\n   */\n  autolink: boolean\n\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   * @default []\n   * @example ['ftp', 'git']\n   */\n  protocols: Array<LinkProtocolOptions | string>\n\n  /**\n   * Default protocol to use when no protocol is specified.\n   * @default 'http'\n   */\n  defaultProtocol: string\n  /**\n   * If enabled, links will be opened on click.\n   * @default true\n   * @example false\n   */\n  openOnClick: boolean | DeprecatedOpenWhenNotEditable\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   * @default true\n   * @example false\n   */\n  linkOnPaste: boolean\n\n  /**\n   * HTML attributes to add to the link element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate: (url: string) => boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.setLink({ href: 'https://tiptap.dev' })\n       */\n      setLink: (attributes: { href: string; target?: string | null; rel?: string | null; class?: string | null }) => ReturnType\n      /**\n       * Toggle a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.toggleLink({ href: 'https://tiptap.dev' })\n       */\n      toggleLink: (attributes: { href: string; target?: string | null; rel?: string | null; class?: string | null }) => ReturnType\n      /**\n       * Unset a link mark\n       * @example editor.commands.unsetLink()\n       */\n      unsetLink: () => ReturnType\n    }\n  }\n}\n\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g\n\nfunction isAllowedUri(uri: string | undefined, protocols?: LinkOptions['protocols']) {\n  const allowedProtocols: string[] = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp']\n\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = (typeof protocol === 'string' ? protocol : protocol.scheme)\n\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol)\n      }\n    })\n  }\n\n  // eslint-disable-next-line no-useless-escape\n  return !uri || uri.replace(ATTR_WHITESPACE, '').match(new RegExp(`^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))`, 'i'))\n}\n\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  exitable: true,\n\n  onCreate() {\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol)\n        return\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes)\n    })\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      validate: url => !!url,\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href')\n        },\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [{\n      tag: 'a[href]',\n      getAttrs: dom => {\n        const href = (dom as HTMLElement).getAttribute('href')\n\n        // prevent XSS attacks\n        if (!href || !isAllowedUri(href, this.options.protocols)) {\n          return false\n        }\n        return null\n      },\n    }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    // prevent XSS attacks\n    if (!isAllowedUri(HTMLAttributes.href, this.options.protocols)) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }), 0]\n    }\n\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setLink:\n        attributes => ({ chain }) => {\n          return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run()\n        },\n\n      toggleLink:\n        attributes => ({ chain }) => {\n          return chain()\n            .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n\n      unsetLink:\n        () => ({ chain }) => {\n          return chain()\n            .unsetMark(this.name, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => {\n          const foundLinks: PasteRuleMatch[] = []\n\n          if (text) {\n            const { validate } = this.options\n            const links = find(text).filter(item => item.isLink && validate(item.value))\n\n            if (links.length) {\n              links.forEach(link => (foundLinks.push({\n                text: link.value,\n                data: {\n                  href: link.href,\n                },\n                index: link.start,\n              })))\n            }\n          }\n\n          return foundLinks\n        },\n        type: this.type,\n        getAttributes: match => {\n          return {\n            href: match.data?.href,\n          }\n        },\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: this.options.validate,\n        }),\n      )\n    }\n\n    if (this.options.openOnClick === true) {\n      plugins.push(\n        clickHandler({\n          type: this.type,\n        }),\n      )\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type,\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}