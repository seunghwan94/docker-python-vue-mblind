{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { combineTransactionSteps, getChangedRanges, findChildrenInRange, getMarksBetween, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { tokenize, find, registerCustomProtocol, reset } from 'linkifyjs';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink;\n  }\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value);\n  }\n  return false;\n}\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nfunction autolink(options) {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      const {\n        tr\n      } = newState;\n      const transform = combineTransactionSteps(oldState.doc, [...transactions]);\n      const changes = getChangedRanges(transform);\n      changes.forEach(({\n        newRange\n      }) => {\n        // Now letâ€™s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock);\n        let textBlock;\n        let textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n        } else if (nodesInChangedRanges.length\n        // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n        && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n        }\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '');\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol));\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false;\n          }\n          linksBeforeSpace.filter(link => link.isLink)\n          // Calculate link position.\n          .map(link => ({\n            ...link,\n            from: lastWordAndBlockOffset + link.start + 1,\n            to: lastWordAndBlockOffset + link.end + 1\n          }))\n          // ignore link inside code mark\n          .filter(link => {\n            if (!newState.schema.marks.code) {\n              return true;\n            }\n            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n          })\n          // validate link\n          .filter(link => options.validate(link.value))\n          // Add link mark.\n          .forEach(link => {\n            if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n              return;\n            }\n            tr.addMark(link.from, link.to, options.type.create({\n              href: link.href\n            }));\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\nfunction clickHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a, _b;\n        if (event.button !== 0) {\n          return false;\n        }\n        if (!view.editable) {\n          return false;\n        }\n        let a = event.target;\n        const els = [];\n        while (a.nodeName !== 'DIV') {\n          els.push(a);\n          a = a.parentNode;\n        }\n        if (!els.find(value => value.nodeName === 'A')) {\n          return false;\n        }\n        const attrs = getAttributes(view.state, options.type.name);\n        const link = event.target;\n        const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;\n        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;\n        if (link && href) {\n          window.open(href, target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\nfunction pasteHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const {\n          state\n        } = view;\n        const {\n          selection\n        } = state;\n        const {\n          empty\n        } = selection;\n        if (empty) {\n          return false;\n        }\n        let textContent = '';\n        slice.content.forEach(node => {\n          textContent += node.textContent;\n        });\n        const link = find(textContent, {\n          defaultProtocol: options.defaultProtocol\n        }).find(item => item.isLink && item.value === textContent);\n        if (!textContent || !link) {\n          return false;\n        }\n        options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n        return true;\n      }\n    }\n  });\n}\nconst pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g;\nfunction isAllowedUri(uri, protocols) {\n  const allowedProtocols = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp'];\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme;\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol);\n      }\n    });\n  }\n  // eslint-disable-next-line no-useless-escape\n  return !uri || uri.replace(ATTR_WHITESPACE, '').match(new RegExp(`^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))`, 'i'));\n}\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nconst Link = Mark.create({\n  name: 'link',\n  priority: 1000,\n  keepOnSplit: false,\n  exitable: true,\n  onCreate() {\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol);\n        return;\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);\n    });\n  },\n  onDestroy() {\n    reset();\n  },\n  inclusive() {\n    return this.options.autolink;\n  },\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null\n      },\n      validate: url => !!url\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href');\n        }\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: 'a[href]',\n      getAttrs: dom => {\n        const href = dom.getAttribute('href');\n        // prevent XSS attacks\n        if (!href || !isAllowedUri(href, this.options.protocols)) {\n          return false;\n        }\n        return null;\n      }\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    // prevent XSS attacks\n    if (!isAllowedUri(HTMLAttributes.href, this.options.protocols)) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, {\n        ...HTMLAttributes,\n        href: ''\n      }), 0];\n    }\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setLink: attributes => ({\n        chain\n      }) => {\n        return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n      },\n      toggleLink: attributes => ({\n        chain\n      }) => {\n        return chain().toggleMark(this.name, attributes, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      },\n      unsetLink: () => ({\n        chain\n      }) => {\n        return chain().unsetMark(this.name, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      }\n    };\n  },\n  addPasteRules() {\n    return [markPasteRule({\n      find: text => {\n        const foundLinks = [];\n        if (text) {\n          const {\n            validate\n          } = this.options;\n          const links = find(text).filter(item => item.isLink && validate(item.value));\n          if (links.length) {\n            links.forEach(link => foundLinks.push({\n              text: link.value,\n              data: {\n                href: link.href\n              },\n              index: link.start\n            }));\n          }\n        }\n        return foundLinks;\n      },\n      type: this.type,\n      getAttributes: match => {\n        var _a;\n        return {\n          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        defaultProtocol: this.options.defaultProtocol,\n        validate: this.options.validate\n      }));\n    }\n    if (this.options.openOnClick === true) {\n      plugins.push(clickHandler({\n        type: this.type\n      }));\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        defaultProtocol: this.options.defaultProtocol,\n        type: this.type\n      }));\n    }\n    return plugins;\n  }\n});\nexport { Link, Link as default, pasteRegex };","map":{"version":3,"names":["combineTransactionSteps","getChangedRanges","findChildrenInRange","getMarksBetween","getAttributes","Mark","mergeAttributes","markPasteRule","tokenize","find","registerCustomProtocol","reset","Plugin","PluginKey","isValidLinkStructure","tokens","length","isLink","includes","value","autolink","options","key","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","doc","eq","preventAutolink","getMeta","tr","transform","changes","forEach","newRange","nodesInChangedRanges","node","isTextblock","textBlock","textBeforeWhitespace","textBetween","pos","nodeSize","undefined","from","to","endsWith","wordsBeforeWhitespace","split","filter","s","lastWordBeforeSpace","lastWordAndBlockOffset","lastIndexOf","linksBeforeSpace","map","t","toObject","defaultProtocol","link","start","end","schema","marks","code","rangeHasMark","validate","item","mark","type","addMark","create","href","steps","clickHandler","props","handleClick","view","event","_a","_b","button","editable","a","target","els","nodeName","push","parentNode","attrs","state","name","window","open","pasteHandler","handlePaste","slice","selection","empty","textContent","content","editor","commands","setMark","pasteRegex","ATTR_WHITESPACE","isAllowedUri","uri","protocols","allowedProtocols","protocol","nextProtocol","scheme","replace","match","RegExp","join","Link","priority","keepOnSplit","exitable","onCreate","optionalSlashes","onDestroy","inclusive","addOptions","openOnClick","linkOnPaste","HTMLAttributes","rel","class","url","addAttributes","default","parseHTML","element","getAttribute","tag","getAttrs","dom","renderHTML","addCommands","setLink","attributes","chain","setMeta","run","toggleLink","toggleMark","extendEmptyMarkRange","unsetLink","unsetMark","addPasteRules","text","foundLinks","links","data","index","addProseMirrorPlugins","plugins"],"sources":["/var/www/front/node_modules/@tiptap/extension-link/dist/index.js"],"sourcesContent":["import { combineTransactionSteps, getChangedRanges, findChildrenInRange, getMarksBetween, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { tokenize, find, registerCustomProtocol, reset } from 'linkifyjs';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens) {\n    if (tokens.length === 1) {\n        return tokens[0].isLink;\n    }\n    if (tokens.length === 3 && tokens[1].isLink) {\n        return ['()', '[]'].includes(tokens[0].value + tokens[2].value);\n    }\n    return false;\n}\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nfunction autolink(options) {\n    return new Plugin({\n        key: new PluginKey('autolink'),\n        appendTransaction: (transactions, oldState, newState) => {\n            /**\n             * Does the transaction change the document?\n             */\n            const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n            /**\n             * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n             */\n            const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n            /**\n             * Prevent autolink if the transaction is not a document change\n             * or if the transaction has the meta `preventAutolink`.\n             */\n            if (!docChanges || preventAutolink) {\n                return;\n            }\n            const { tr } = newState;\n            const transform = combineTransactionSteps(oldState.doc, [...transactions]);\n            const changes = getChangedRanges(transform);\n            changes.forEach(({ newRange }) => {\n                // Now letâ€™s see if we can add new links.\n                const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock);\n                let textBlock;\n                let textBeforeWhitespace;\n                if (nodesInChangedRanges.length > 1) {\n                    // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n                }\n                else if (nodesInChangedRanges.length\n                    // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n                    && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n                }\n                if (textBlock && textBeforeWhitespace) {\n                    const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '');\n                    if (wordsBeforeWhitespace.length <= 0) {\n                        return false;\n                    }\n                    const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n                    const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n                    if (!lastWordBeforeSpace) {\n                        return false;\n                    }\n                    const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol));\n                    if (!isValidLinkStructure(linksBeforeSpace)) {\n                        return false;\n                    }\n                    linksBeforeSpace\n                        .filter(link => link.isLink)\n                        // Calculate link position.\n                        .map(link => ({\n                        ...link,\n                        from: lastWordAndBlockOffset + link.start + 1,\n                        to: lastWordAndBlockOffset + link.end + 1,\n                    }))\n                        // ignore link inside code mark\n                        .filter(link => {\n                        if (!newState.schema.marks.code) {\n                            return true;\n                        }\n                        return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n                    })\n                        // validate link\n                        .filter(link => options.validate(link.value))\n                        // Add link mark.\n                        .forEach(link => {\n                        if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                            return;\n                        }\n                        tr.addMark(link.from, link.to, options.type.create({\n                            href: link.href,\n                        }));\n                    });\n                }\n            });\n            if (!tr.steps.length) {\n                return;\n            }\n            return tr;\n        },\n    });\n}\n\nfunction clickHandler(options) {\n    return new Plugin({\n        key: new PluginKey('handleClickLink'),\n        props: {\n            handleClick: (view, pos, event) => {\n                var _a, _b;\n                if (event.button !== 0) {\n                    return false;\n                }\n                if (!view.editable) {\n                    return false;\n                }\n                let a = event.target;\n                const els = [];\n                while (a.nodeName !== 'DIV') {\n                    els.push(a);\n                    a = a.parentNode;\n                }\n                if (!els.find(value => value.nodeName === 'A')) {\n                    return false;\n                }\n                const attrs = getAttributes(view.state, options.type.name);\n                const link = event.target;\n                const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;\n                const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;\n                if (link && href) {\n                    window.open(href, target);\n                    return true;\n                }\n                return false;\n            },\n        },\n    });\n}\n\nfunction pasteHandler(options) {\n    return new Plugin({\n        key: new PluginKey('handlePasteLink'),\n        props: {\n            handlePaste: (view, event, slice) => {\n                const { state } = view;\n                const { selection } = state;\n                const { empty } = selection;\n                if (empty) {\n                    return false;\n                }\n                let textContent = '';\n                slice.content.forEach(node => {\n                    textContent += node.textContent;\n                });\n                const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(item => item.isLink && item.value === textContent);\n                if (!textContent || !link) {\n                    return false;\n                }\n                options.editor.commands.setMark(options.type, {\n                    href: link.href,\n                });\n                return true;\n            },\n        },\n    });\n}\n\nconst pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g;\nfunction isAllowedUri(uri, protocols) {\n    const allowedProtocols = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp'];\n    if (protocols) {\n        protocols.forEach(protocol => {\n            const nextProtocol = (typeof protocol === 'string' ? protocol : protocol.scheme);\n            if (nextProtocol) {\n                allowedProtocols.push(nextProtocol);\n            }\n        });\n    }\n    // eslint-disable-next-line no-useless-escape\n    return !uri || uri.replace(ATTR_WHITESPACE, '').match(new RegExp(`^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))`, 'i'));\n}\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nconst Link = Mark.create({\n    name: 'link',\n    priority: 1000,\n    keepOnSplit: false,\n    exitable: true,\n    onCreate() {\n        this.options.protocols.forEach(protocol => {\n            if (typeof protocol === 'string') {\n                registerCustomProtocol(protocol);\n                return;\n            }\n            registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);\n        });\n    },\n    onDestroy() {\n        reset();\n    },\n    inclusive() {\n        return this.options.autolink;\n    },\n    addOptions() {\n        return {\n            openOnClick: true,\n            linkOnPaste: true,\n            autolink: true,\n            protocols: [],\n            defaultProtocol: 'http',\n            HTMLAttributes: {\n                target: '_blank',\n                rel: 'noopener noreferrer nofollow',\n                class: null,\n            },\n            validate: url => !!url,\n        };\n    },\n    addAttributes() {\n        return {\n            href: {\n                default: null,\n                parseHTML(element) {\n                    return element.getAttribute('href');\n                },\n            },\n            target: {\n                default: this.options.HTMLAttributes.target,\n            },\n            rel: {\n                default: this.options.HTMLAttributes.rel,\n            },\n            class: {\n                default: this.options.HTMLAttributes.class,\n            },\n        };\n    },\n    parseHTML() {\n        return [{\n                tag: 'a[href]',\n                getAttrs: dom => {\n                    const href = dom.getAttribute('href');\n                    // prevent XSS attacks\n                    if (!href || !isAllowedUri(href, this.options.protocols)) {\n                        return false;\n                    }\n                    return null;\n                },\n            }];\n    },\n    renderHTML({ HTMLAttributes }) {\n        // prevent XSS attacks\n        if (!isAllowedUri(HTMLAttributes.href, this.options.protocols)) {\n            // strip out the href\n            return ['a', mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }), 0];\n        }\n        return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setLink: attributes => ({ chain }) => {\n                return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n            },\n            toggleLink: attributes => ({ chain }) => {\n                return chain()\n                    .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n                    .setMeta('preventAutolink', true)\n                    .run();\n            },\n            unsetLink: () => ({ chain }) => {\n                return chain()\n                    .unsetMark(this.name, { extendEmptyMarkRange: true })\n                    .setMeta('preventAutolink', true)\n                    .run();\n            },\n        };\n    },\n    addPasteRules() {\n        return [\n            markPasteRule({\n                find: text => {\n                    const foundLinks = [];\n                    if (text) {\n                        const { validate } = this.options;\n                        const links = find(text).filter(item => item.isLink && validate(item.value));\n                        if (links.length) {\n                            links.forEach(link => (foundLinks.push({\n                                text: link.value,\n                                data: {\n                                    href: link.href,\n                                },\n                                index: link.start,\n                            })));\n                        }\n                    }\n                    return foundLinks;\n                },\n                type: this.type,\n                getAttributes: match => {\n                    var _a;\n                    return {\n                        href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href,\n                    };\n                },\n            }),\n        ];\n    },\n    addProseMirrorPlugins() {\n        const plugins = [];\n        if (this.options.autolink) {\n            plugins.push(autolink({\n                type: this.type,\n                defaultProtocol: this.options.defaultProtocol,\n                validate: this.options.validate,\n            }));\n        }\n        if (this.options.openOnClick === true) {\n            plugins.push(clickHandler({\n                type: this.type,\n            }));\n        }\n        if (this.options.linkOnPaste) {\n            plugins.push(pasteHandler({\n                editor: this.editor,\n                defaultProtocol: this.options.defaultProtocol,\n                type: this.type,\n            }));\n        }\n        return plugins;\n    },\n});\n\nexport { Link, Link as default, pasteRegex };\n//# sourceMappingURL=index.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}